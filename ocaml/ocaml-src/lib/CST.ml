(* Generated by ocaml-tree-sitter. *)
(*
   python grammar

   entrypoint: module
*)

open! Sexplib.Conv
open Tree_sitter_run

type string_start = Token.t
[@@deriving sexp_of]

type integer = Token.t
[@@deriving sexp_of]

type keyword_identifier = [
    `Print of Token.t (* "print" *)
  | `Exec of Token.t (* "exec" *)
  | `Async of Token.t (* "async" *)
  | `Await of Token.t (* "await" *)
]
[@@deriving sexp_of]

type dedent = Token.t
[@@deriving sexp_of]

type escape_interpolation = [
    `LCURLLCURL of Token.t (* "{{" *)
  | `RCURLRCURL of Token.t (* "}}" *)
]
[@@deriving sexp_of]

type identifier = Token.t (* pattern [_\p{XID_Start}][_\p{XID_Continue}]* *)
[@@deriving sexp_of]

type float_ = Token.t
[@@deriving sexp_of]

type type_conversion = Token.t (* pattern ![a-z] *)
[@@deriving sexp_of]

type escape_sequence = Token.t
[@@deriving sexp_of]

type import_prefix = Token.t (* "." *) list (* one or more *)
[@@deriving sexp_of]

type newline = Token.t
[@@deriving sexp_of]

type string_end = Token.t
[@@deriving sexp_of]

type string_content = Token.t
[@@deriving sexp_of]

type indent = Token.t
[@@deriving sexp_of]

type dotted_name = (
    identifier (*tok*)
  * (Token.t (* "." *) * identifier (*tok*)) list (* zero or more *)
)
[@@deriving sexp_of]

type named_expresssion_lhs = [
    `Id of identifier (*tok*)
  | `Match of Token.t (* "match" *)
]
[@@deriving sexp_of]

type relative_import = (import_prefix * dotted_name option)
[@@deriving sexp_of]

type anon_choice_id_b80cb38 = [
    `Id of identifier (*tok*)
  | `Choice_print of keyword_identifier
  | `Subs of subscript
  | `Attr of attribute
]

and anon_choice_pair_002ffed = [
    `Pair of pair
  | `Dict_splat of dictionary_splat
]

and anon_choice_type_03d361f = [
    `Exp of type_
  | `Yield of yield
  | `List_splat of list_splat
  | `Paren_list_splat of parenthesized_list_splat
]

and anon_choice_type_a577897 = [
    `Exp of type_
  | `Slice of (
        type_ option
      * Token.t (* ":" *)
      * type_ option
      * (Token.t (* ":" *) * type_ option) option
    )
]

and anon_choice_type_aad5b2d = [
    `Exp of type_
  | `List_splat of list_splat
  | `Dict_splat of dictionary_splat
  | `Paren_list_splat of parenthesized_list_splat
  | `Kw_arg of (
        [
            `Id of identifier (*tok*)
          | `Choice_print of keyword_identifier
          | `Match of Token.t (* "match" *)
        ]
      * Token.t (* "=" *)
      * type_
    )
]

and argument_list = (
    Token.t (* "(" *)
  * (
        anon_choice_type_aad5b2d
      * (Token.t (* "," *) * anon_choice_type_aad5b2d)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and attribute = (primary_expression * Token.t (* "." *) * identifier (*tok*))

and binary_operator = [
    `Prim_exp_PLUS_prim_exp of (
        primary_expression * Token.t (* "+" *) * primary_expression
    )
  | `Prim_exp_DASH_prim_exp of (
        primary_expression * Token.t (* "-" *) * primary_expression
    )
  | `Prim_exp_STAR_prim_exp of (
        primary_expression * Token.t (* "*" *) * primary_expression
    )
  | `Prim_exp_AT_prim_exp of (
        primary_expression * Token.t (* "@" *) * primary_expression
    )
  | `Prim_exp_SLASH_prim_exp of (
        primary_expression * Token.t (* "/" *) * primary_expression
    )
  | `Prim_exp_PERC_prim_exp of (
        primary_expression * Token.t (* "%" *) * primary_expression
    )
  | `Prim_exp_SLASHSLASH_prim_exp of (
        primary_expression * Token.t (* "//" *) * primary_expression
    )
  | `Prim_exp_STARSTAR_prim_exp of (
        primary_expression * Token.t (* "**" *) * primary_expression
    )
  | `Prim_exp_BAR_prim_exp of (
        primary_expression * Token.t (* "|" *) * primary_expression
    )
  | `Prim_exp_AMP_prim_exp of (
        primary_expression * Token.t (* "&" *) * primary_expression
    )
  | `Prim_exp_HAT_prim_exp of (
        primary_expression * Token.t (* "^" *) * primary_expression
    )
  | `Prim_exp_LTLT_prim_exp of (
        primary_expression * Token.t (* "<<" *) * primary_expression
    )
  | `Prim_exp_GTGT_prim_exp of (
        primary_expression * Token.t (* ">>" *) * primary_expression
    )
]

and boolean_operator = [
    `Exp_and_exp of (type_ * Token.t (* "and" *) * type_)
  | `Exp_or_exp of (type_ * Token.t (* "or" *) * type_)
]

and collection_elements = (
    anon_choice_type_03d361f
  * (Token.t (* "," *) * anon_choice_type_03d361f) list (* zero or more *)
  * Token.t (* "," *) option
)

and comprehension_clauses = (
    for_in_clause
  * [ `For_in_clause of for_in_clause | `If_clause of if_clause ]
      list (* zero or more *)
)

and dictionary_splat = (Token.t (* "**" *) * type_)

and dictionary_splat_pattern = (Token.t (* "**" *) * anon_choice_id_b80cb38)

and expression = [
    `Comp_op of (
        primary_expression
      * (
            [
                `LT of Token.t (* "<" *)
              | `LTEQ of Token.t (* "<=" *)
              | `EQEQ of Token.t (* "==" *)
              | `BANGEQ of Token.t (* "!=" *)
              | `GTEQ of Token.t (* ">=" *)
              | `GT of Token.t (* ">" *)
              | `LTGT of Token.t (* "<>" *)
              | `In of Token.t (* "in" *)
              | `Not_in of (Token.t (* "not" *) * Token.t (* "in" *))
              | `Is of Token.t (* "is" *)
              | `Is_not of (Token.t (* "is" *) * Token.t (* "not" *))
            ]
          * primary_expression
        )
          list (* one or more *)
    )
  | `Not_op of (Token.t (* "not" *) * type_)
  | `Bool_op of boolean_operator
  | `Await of (Token.t (* "await" *) * type_)
  | `Lambda of (
        Token.t (* "lambda" *)
      * lambda_parameters option
      * Token.t (* ":" *)
      * type_
    )
  | `Prim_exp of primary_expression
  | `Cond_exp of (
        type_ * Token.t (* "if" *) * type_ * Token.t (* "else" *) * type_
    )
  | `Named_exp of (named_expresssion_lhs * Token.t (* ":=" *) * type_)
  | `As_pat of (type_ * Token.t (* "as" *) * type_)
]

and expression_list = (
    type_
  * [
        `COMMA of Token.t (* "," *)
      | `Rep1_COMMA_exp_opt_COMMA of (
            (Token.t (* "," *) * type_) list (* one or more *)
          * Token.t (* "," *) option
        )
    ]
)

and expression_within_for_in_clause = [
    `Exp of type_
  | `Lambda_within_for_in_clause of (
        Token.t (* "lambda" *)
      * lambda_parameters option
      * Token.t (* ":" *)
      * expression_within_for_in_clause
    )
]

and expressions = [ `Exp of type_ | `Exp_list of expression_list ]

and for_in_clause = (
    Token.t (* "async" *) option
  * Token.t (* "for" *)
  * left_hand_side
  * Token.t (* "in" *)
  * expression_within_for_in_clause
  * (Token.t (* "," *) * expression_within_for_in_clause)
      list (* zero or more *)
  * Token.t (* "," *) option
)

and format_expression = (Token.t (* "{" *) * type_ * Token.t (* "}" *))

and format_specifier = (
    Token.t (* ":" *)
  * [ `LBRA of Token.t (* [^{}\n]+ *) | `Format_exp of format_expression ]
      list (* zero or more *)
)

and generator_expression = (
    Token.t (* "(" *) * type_ * comprehension_clauses * Token.t (* ")" *)
)

and if_clause = (Token.t (* "if" *) * type_)

and interpolation = (
    Token.t (* "{" *)
  * type_
  * Token.t (* "=" *) option
  * type_conversion (*tok*) option
  * format_specifier option
  * Token.t (* "}" *)
)

and lambda_parameters = parameters_

and left_hand_side = [
    `Pat of pattern
  | `Pat_list of (
        pattern
      * [
            `COMMA of Token.t (* "," *)
          | `Rep1_COMMA_pat_opt_COMMA of (
                (Token.t (* "," *) * pattern) list (* one or more *)
              * Token.t (* "," *) option
            )
        ]
    )
]

and list_splat = (Token.t (* "*" *) * type_)

and list_splat_pattern = (Token.t (* "*" *) * anon_choice_id_b80cb38)

and pair = (type_ * Token.t (* ":" *) * type_)

and parameter = [
    `Id of identifier (*tok*)
  | `Typed_param of (
        [
            `Id of identifier (*tok*)
          | `List_splat_pat of list_splat_pattern
          | `Dict_splat_pat of dictionary_splat_pattern
        ]
      * Token.t (* ":" *)
      * type_
    )
  | `Defa_param of (identifier (*tok*) * Token.t (* "=" *) * type_)
  | `Typed_defa_param of (
        identifier (*tok*) * Token.t (* ":" *) * type_ * Token.t (* "=" *)
      * type_
    )
  | `List_splat_pat of list_splat_pattern
  | `Tuple_pat of tuple_pattern
  | `Kw_sepa of Token.t (* "*" *)
  | `Posi_sepa of Token.t (* "/" *)
  | `Dict_splat_pat of dictionary_splat_pattern
]

and parameters_ = (
    parameter
  * (Token.t (* "," *) * parameter) list (* zero or more *)
  * Token.t (* "," *) option
)

and parenthesized_list_splat = (
    Token.t (* "(" *)
  * [
        `Paren_list_splat of parenthesized_list_splat
      | `List_splat of list_splat
    ]
  * Token.t (* ")" *)
)

and pattern = [
    `Id of identifier (*tok*)
  | `Match of Token.t (* "match" *)
  | `Choice_print of keyword_identifier
  | `Subs of subscript
  | `Attr of attribute
  | `List_splat_pat of list_splat_pattern
  | `Tuple_pat of tuple_pattern
  | `List_pat of (Token.t (* "[" *) * patterns option * Token.t (* "]" *))
]

and patterns = (
    pattern
  * (Token.t (* "," *) * pattern) list (* zero or more *)
  * Token.t (* "," *) option
)

and primary_expression = [
    `Bin_op of binary_operator
  | `Id of identifier (*tok*)
  | `Match of Token.t (* "match" *)
  | `Choice_print of keyword_identifier
  | `Str of string_
  | `Conc_str of (string_ * string_ list (* one or more *))
  | `Int of integer (*tok*)
  | `Float of float_ (*tok*)
  | `True of Token.t (* "True" *)
  | `False of Token.t (* "False" *)
  | `None of Token.t (* "None" *)
  | `Un_op of (
        [
            `PLUS of Token.t (* "+" *)
          | `DASH of Token.t (* "-" *)
          | `TILDE of Token.t (* "~" *)
        ]
      * primary_expression
    )
  | `Attr of attribute
  | `Subs of subscript
  | `Call of (
        primary_expression
      * [ `Gene_exp of generator_expression | `Arg_list of argument_list ]
    )
  | `List of (
        Token.t (* "[" *)
      * collection_elements option
      * Token.t (* "]" *)
    )
  | `List_comp of (
        Token.t (* "[" *) * type_ * comprehension_clauses * Token.t (* "]" *)
    )
  | `Dict of (
        Token.t (* "{" *)
      * (
            anon_choice_pair_002ffed
          * (Token.t (* "," *) * anon_choice_pair_002ffed)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Dict_comp of (
        Token.t (* "{" *) * pair * comprehension_clauses * Token.t (* "}" *)
    )
  | `Set of (Token.t (* "{" *) * collection_elements * Token.t (* "}" *))
  | `Set_comp of (
        Token.t (* "{" *) * type_ * comprehension_clauses * Token.t (* "}" *)
    )
  | `Tuple of (
        Token.t (* "(" *)
      * collection_elements option
      * Token.t (* ")" *)
    )
  | `Paren_exp of (
        Token.t (* "(" *)
      * [ `Exp of type_ | `Yield of yield ]
      * Token.t (* ")" *)
    )
  | `Gene_exp of generator_expression
  | `Ellips of Token.t (* "..." *)
]

and string_ = (
    string_start (*tok*)
  * [
        `Interp of interpolation
      | `Esc_interp of escape_interpolation
      | `Esc_seq of escape_sequence (*tok*)
      | `Not_esc_seq of Token.t (* "\\" *)
      | `Str_content of string_content (*tok*)
    ]
      list (* zero or more *)
  * string_end (*tok*)
)

and subscript = (
    primary_expression
  * Token.t (* "[" *)
  * anon_choice_type_a577897
  * (Token.t (* "," *) * anon_choice_type_a577897) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

and tuple_pattern = (Token.t (* "(" *) * patterns option * Token.t (* ")" *))

and type_ = expression

and yield = (
    Token.t (* "yield" *)
  * [
        `From_exp of (Token.t (* "from" *) * type_)
      | `Opt_choice_exp of expressions option
    ]
)
[@@deriving sexp_of]

type anon_choice_dotted_name_c5c573a = [
    `Dotted_name of dotted_name
  | `Alia_import of (dotted_name * Token.t (* "as" *) * identifier (*tok*))
]
[@@deriving sexp_of]

type chevron = (Token.t (* ">>" *) * type_)
[@@deriving sexp_of]

type with_item = type_
[@@deriving sexp_of]

type anon_choice_type_756d23d = [
    `Exp of type_
  | `List_splat_pat of list_splat_pattern
]
[@@deriving sexp_of]

type decorator = (Token.t (* "@" *) * primary_expression * newline (*tok*))
[@@deriving sexp_of]

type parameters = (
    Token.t (* "(" *)
  * lambda_parameters option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type assignment = (
    left_hand_side
  * [
        `EQ_right_hand_side of (Token.t (* "=" *) * right_hand_side)
      | `COLON_type of (Token.t (* ":" *) * type_)
      | `COLON_type_EQ_right_hand_side of (
            Token.t (* ":" *) * type_ * Token.t (* "=" *) * right_hand_side
        )
    ]
)

and augmented_assignment = (
    left_hand_side
  * [
        `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `ATEQ of Token.t (* "@=" *)
      | `SLASHSLASHEQ of Token.t (* "//=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `STARSTAREQ of Token.t (* "**=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `BAREQ of Token.t (* "|=" *)
    ]
  * right_hand_side
)

and right_hand_side = [
    `Exp of type_
  | `Exp_list of expression_list
  | `Assign of assignment
  | `Augm_assign of augmented_assignment
  | `Yield of yield
]
[@@deriving sexp_of]

type import_list = (
    anon_choice_dotted_name_c5c573a
  * (Token.t (* "," *) * anon_choice_dotted_name_c5c573a)
      list (* zero or more *)
  * Token.t (* "," *) option
)
[@@deriving sexp_of]

type print_statement = [
    `Print_chev_rep_COMMA_exp_opt_COMMA of (
        Token.t (* "print" *)
      * chevron
      * (Token.t (* "," *) * type_) list (* zero or more *)
      * Token.t (* "," *) option
    )
  | `Print_exp_rep_COMMA_exp_opt_COMMA of (
        Token.t (* "print" *)
      * type_
      * (Token.t (* "," *) * type_) list (* zero or more *)
      * Token.t (* "," *) option
    )
]
[@@deriving sexp_of]

type with_clause = [
    `With_item_rep_COMMA_with_item of (
        with_item
      * (Token.t (* "," *) * with_item) list (* zero or more *)
    )
  | `LPAR_with_item_rep_COMMA_with_item_RPAR of (
        Token.t (* "(" *)
      * with_item
      * (Token.t (* "," *) * with_item) list (* zero or more *)
      * Token.t (* ")" *)
    )
]
[@@deriving sexp_of]

type expression_statement = [
    `Exp of type_
  | `Exp_rep_COMMA_exp_opt_COMMA of (
        type_
      * (Token.t (* "," *) * type_) list (* zero or more *)
      * Token.t (* "," *) option
    )
  | `Assign of assignment
  | `Augm_assign of augmented_assignment
  | `Yield of yield
]
[@@deriving sexp_of]

type simple_statement = [
    `Future_import_stmt of (
        Token.t (* "from" *)
      * Token.t (* "__future__" *)
      * Token.t (* "import" *)
      * [
            `Import_list of import_list
          | `LPAR_import_list_RPAR of (
                Token.t (* "(" *) * import_list * Token.t (* ")" *)
            )
        ]
    )
  | `Import_stmt of (Token.t (* "import" *) * import_list)
  | `Import_from_stmt of (
        Token.t (* "from" *)
      * [ `Rela_import of relative_import | `Dotted_name of dotted_name ]
      * Token.t (* "import" *)
      * [
            `Wild_import of Token.t (* "*" *)
          | `Import_list of import_list
          | `LPAR_import_list_RPAR of (
                Token.t (* "(" *) * import_list * Token.t (* ")" *)
            )
        ]
    )
  | `Print_stmt of print_statement
  | `Assert_stmt of (
        Token.t (* "assert" *)
      * type_
      * (Token.t (* "," *) * type_) list (* zero or more *)
    )
  | `Exp_stmt of expression_statement
  | `Ret_stmt of (Token.t (* "return" *) * expressions option)
  | `Delete_stmt of (Token.t (* "del" *) * expressions)
  | `Raise_stmt of (
        Token.t (* "raise" *)
      * expressions option
      * (Token.t (* "from" *) * type_) option
    )
  | `Pass_stmt of Token.t (* "pass" *)
  | `Brk_stmt of Token.t (* "break" *)
  | `Cont_stmt of Token.t (* "continue" *)
  | `Global_stmt of (
        Token.t (* "global" *)
      * identifier (*tok*)
      * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
    )
  | `Nonl_stmt of (
        Token.t (* "nonlocal" *)
      * identifier (*tok*)
      * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
    )
  | `Exec_stmt of (
        Token.t (* "exec" *)
      * string_
      * (
            Token.t (* "in" *)
          * type_
          * (Token.t (* "," *) * type_) list (* zero or more *)
        )
          option
    )
]
[@@deriving sexp_of]

type simple_statements = (
    simple_statement
  * (Token.t (* ";" *) * simple_statement) list (* zero or more *)
  * Token.t (* ";" *) option
  * newline (*tok*)
)
[@@deriving sexp_of]

type block = (module_ * dedent (*tok*))

and case_clause = (
    Token.t (* "case" *)
  * anon_choice_type_756d23d
  * (Token.t (* "," *) * anon_choice_type_756d23d) list (* zero or more *)
  * Token.t (* "," *) option
  * if_clause option
  * Token.t (* ":" *)
  * suite
)

and class_definition = (
    Token.t (* "class" *)
  * identifier (*tok*)
  * argument_list option
  * Token.t (* ":" *)
  * suite
)

and compound_statement = [
    `If_stmt of (
        Token.t (* "if" *)
      * type_
      * Token.t (* ":" *)
      * suite
      * elif_clause list (* zero or more *)
      * else_clause option
    )
  | `For_stmt of (
        Token.t (* "async" *) option
      * Token.t (* "for" *)
      * left_hand_side
      * Token.t (* "in" *)
      * expressions
      * Token.t (* ":" *)
      * suite
      * else_clause option
    )
  | `While_stmt of (
        Token.t (* "while" *)
      * type_
      * Token.t (* ":" *)
      * suite
      * else_clause option
    )
  | `Try_stmt of (
        Token.t (* "try" *)
      * Token.t (* ":" *)
      * suite
      * [
            `Rep1_except_clause_opt_else_clause_opt_fina_clause of (
                except_clause list (* one or more *)
              * else_clause option
              * finally_clause option
            )
          | `Fina_clause of finally_clause
        ]
    )
  | `With_stmt of (
        Token.t (* "async" *) option
      * Token.t (* "with" *)
      * with_clause
      * Token.t (* ":" *)
      * suite
    )
  | `Func_defi of function_definition
  | `Class_defi of class_definition
  | `Deco_defi of (
        decorator list (* one or more *)
      * [
            `Class_defi of class_definition
          | `Func_defi of function_definition
        ]
    )
  | `Match_stmt of (
        Token.t (* "match" *)
      * type_
      * (Token.t (* "," *) * type_) list (* zero or more *)
      * Token.t (* "," *) option
      * Token.t (* ":" *)
      * case_clause list (* zero or more *)
    )
]

and elif_clause = (Token.t (* "elif" *) * type_ * Token.t (* ":" *) * suite)

and else_clause = (Token.t (* "else" *) * Token.t (* ":" *) * suite)

and except_clause = (
    Token.t (* "except" *)
  * (
        type_
      * ([ `As of Token.t (* "as" *) | `COMMA of Token.t (* "," *) ] * type_)
          option
    )
      option
  * Token.t (* ":" *)
  * suite
)

and finally_clause = (Token.t (* "finally" *) * Token.t (* ":" *) * suite)

and function_definition = (
    Token.t (* "async" *) option
  * Token.t (* "def" *)
  * identifier (*tok*)
  * parameters
  * (Token.t (* "->" *) * type_) option
  * Token.t (* ":" *)
  * suite
)

and module_ = statement list (* zero or more *)

and statement = [
    `Simple_stmts of simple_statements
  | `Choice_if_stmt of compound_statement
]

and suite = [
    `Simple_stmts of simple_statements
  | `Indent_blk of (indent (*tok*) * block)
  | `Nl of newline (*tok*)
]
[@@deriving sexp_of]

type true_ (* inlined *) = Token.t (* "True" *)
[@@deriving sexp_of]

type wildcard_import (* inlined *) = Token.t (* "*" *)
[@@deriving sexp_of]

type ellipsis (* inlined *) = Token.t (* "..." *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type keyword_separator (* inlined *) = Token.t (* "*" *)
[@@deriving sexp_of]

type positional_separator (* inlined *) = Token.t (* "/" *)
[@@deriving sexp_of]

type not_escape_sequence (* inlined *) = Token.t (* "\\" *)
[@@deriving sexp_of]

type continue_statement (* inlined *) = Token.t (* "continue" *)
[@@deriving sexp_of]

type pass_statement (* inlined *) = Token.t (* "pass" *)
[@@deriving sexp_of]

type break_statement (* inlined *) = Token.t (* "break" *)
[@@deriving sexp_of]

type none (* inlined *) = Token.t (* "None" *)
[@@deriving sexp_of]

type false_ (* inlined *) = Token.t (* "False" *)
[@@deriving sexp_of]

type global_statement (* inlined *) = (
    Token.t (* "global" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
)
[@@deriving sexp_of]

type nonlocal_statement (* inlined *) = (
    Token.t (* "nonlocal" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
)
[@@deriving sexp_of]

type aliased_import (* inlined *) = (
    dotted_name * Token.t (* "as" *) * identifier (*tok*)
)
[@@deriving sexp_of]

type as_pattern (* inlined *) = (type_ * Token.t (* "as" *) * type_)
[@@deriving sexp_of]

type await (* inlined *) = (Token.t (* "await" *) * type_)
[@@deriving sexp_of]

type call (* inlined *) = (
    primary_expression
  * [ `Gene_exp of generator_expression | `Arg_list of argument_list ]
)
[@@deriving sexp_of]

type comparison_operator (* inlined *) = (
    primary_expression
  * (
        [
            `LT of Token.t (* "<" *)
          | `LTEQ of Token.t (* "<=" *)
          | `EQEQ of Token.t (* "==" *)
          | `BANGEQ of Token.t (* "!=" *)
          | `GTEQ of Token.t (* ">=" *)
          | `GT of Token.t (* ">" *)
          | `LTGT of Token.t (* "<>" *)
          | `In of Token.t (* "in" *)
          | `Not_in of (Token.t (* "not" *) * Token.t (* "in" *))
          | `Is of Token.t (* "is" *)
          | `Is_not of (Token.t (* "is" *) * Token.t (* "not" *))
        ]
      * primary_expression
    )
      list (* one or more *)
)
[@@deriving sexp_of]

type concatenated_string (* inlined *) = (
    string_
  * string_ list (* one or more *)
)
[@@deriving sexp_of]

type conditional_expression (* inlined *) = (
    type_ * Token.t (* "if" *) * type_ * Token.t (* "else" *) * type_
)
[@@deriving sexp_of]

type default_parameter (* inlined *) = (
    identifier (*tok*) * Token.t (* "=" *) * type_
)
[@@deriving sexp_of]

type dictionary (* inlined *) = (
    Token.t (* "{" *)
  * (
        anon_choice_pair_002ffed
      * (Token.t (* "," *) * anon_choice_pair_002ffed)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type dictionary_comprehension (* inlined *) = (
    Token.t (* "{" *) * pair * comprehension_clauses * Token.t (* "}" *)
)
[@@deriving sexp_of]

type keyword_argument (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `Choice_print of keyword_identifier
      | `Match of Token.t (* "match" *)
    ]
  * Token.t (* "=" *)
  * type_
)
[@@deriving sexp_of]

type lambda (* inlined *) = (
    Token.t (* "lambda" *)
  * lambda_parameters option
  * Token.t (* ":" *)
  * type_
)
[@@deriving sexp_of]

type lambda_within_for_in_clause (* inlined *) = (
    Token.t (* "lambda" *)
  * lambda_parameters option
  * Token.t (* ":" *)
  * expression_within_for_in_clause
)
[@@deriving sexp_of]

type list_ (* inlined *) = (
    Token.t (* "[" *)
  * collection_elements option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type list_comprehension (* inlined *) = (
    Token.t (* "[" *) * type_ * comprehension_clauses * Token.t (* "]" *)
)
[@@deriving sexp_of]

type list_pattern (* inlined *) = (
    Token.t (* "[" *)
  * patterns option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type named_expression (* inlined *) = (
    named_expresssion_lhs * Token.t (* ":=" *) * type_
)
[@@deriving sexp_of]

type not_operator (* inlined *) = (Token.t (* "not" *) * type_)
[@@deriving sexp_of]

type parenthesized_expression (* inlined *) = (
    Token.t (* "(" *)
  * [ `Exp of type_ | `Yield of yield ]
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type pattern_list (* inlined *) = (
    pattern
  * [
        `COMMA of Token.t (* "," *)
      | `Rep1_COMMA_pat_opt_COMMA of (
            (Token.t (* "," *) * pattern) list (* one or more *)
          * Token.t (* "," *) option
        )
    ]
)
[@@deriving sexp_of]

type set (* inlined *) = (
    Token.t (* "{" *) * collection_elements * Token.t (* "}" *)
)
[@@deriving sexp_of]

type set_comprehension (* inlined *) = (
    Token.t (* "{" *) * type_ * comprehension_clauses * Token.t (* "}" *)
)
[@@deriving sexp_of]

type slice (* inlined *) = (
    type_ option
  * Token.t (* ":" *)
  * type_ option
  * (Token.t (* ":" *) * type_ option) option
)
[@@deriving sexp_of]

type tuple (* inlined *) = (
    Token.t (* "(" *)
  * collection_elements option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type typed_default_parameter (* inlined *) = (
    identifier (*tok*) * Token.t (* ":" *) * type_ * Token.t (* "=" *)
  * type_
)
[@@deriving sexp_of]

type typed_parameter (* inlined *) = (
    [
        `Id of identifier (*tok*)
      | `List_splat_pat of list_splat_pattern
      | `Dict_splat_pat of dictionary_splat_pattern
    ]
  * Token.t (* ":" *)
  * type_
)
[@@deriving sexp_of]

type unary_operator (* inlined *) = (
    [
        `PLUS of Token.t (* "+" *)
      | `DASH of Token.t (* "-" *)
      | `TILDE of Token.t (* "~" *)
    ]
  * primary_expression
)
[@@deriving sexp_of]

type exec_statement (* inlined *) = (
    Token.t (* "exec" *)
  * string_
  * (
        Token.t (* "in" *)
      * type_
      * (Token.t (* "," *) * type_) list (* zero or more *)
    )
      option
)
[@@deriving sexp_of]

type assert_statement (* inlined *) = (
    Token.t (* "assert" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
)
[@@deriving sexp_of]

type delete_statement (* inlined *) = (Token.t (* "del" *) * expressions)
[@@deriving sexp_of]

type return_statement (* inlined *) = (
    Token.t (* "return" *)
  * expressions option
)
[@@deriving sexp_of]

type raise_statement (* inlined *) = (
    Token.t (* "raise" *)
  * expressions option
  * (Token.t (* "from" *) * type_) option
)
[@@deriving sexp_of]

type import_from_statement (* inlined *) = (
    Token.t (* "from" *)
  * [ `Rela_import of relative_import | `Dotted_name of dotted_name ]
  * Token.t (* "import" *)
  * [
        `Wild_import of Token.t (* "*" *)
      | `Import_list of import_list
      | `LPAR_import_list_RPAR of (
            Token.t (* "(" *) * import_list * Token.t (* ")" *)
        )
    ]
)
[@@deriving sexp_of]

type future_import_statement (* inlined *) = (
    Token.t (* "from" *)
  * Token.t (* "__future__" *)
  * Token.t (* "import" *)
  * [
        `Import_list of import_list
      | `LPAR_import_list_RPAR of (
            Token.t (* "(" *) * import_list * Token.t (* ")" *)
        )
    ]
)
[@@deriving sexp_of]

type import_statement (* inlined *) = (Token.t (* "import" *) * import_list)
[@@deriving sexp_of]

type decorated_definition (* inlined *) = (
    decorator list (* one or more *)
  * [ `Class_defi of class_definition | `Func_defi of function_definition ]
)
[@@deriving sexp_of]

type for_statement (* inlined *) = (
    Token.t (* "async" *) option
  * Token.t (* "for" *)
  * left_hand_side
  * Token.t (* "in" *)
  * expressions
  * Token.t (* ":" *)
  * suite
  * else_clause option
)
[@@deriving sexp_of]

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * type_
  * Token.t (* ":" *)
  * suite
  * elif_clause list (* zero or more *)
  * else_clause option
)
[@@deriving sexp_of]

type match_statement (* inlined *) = (
    Token.t (* "match" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ":" *)
  * case_clause list (* zero or more *)
)
[@@deriving sexp_of]

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * Token.t (* ":" *)
  * suite
  * [
        `Rep1_except_clause_opt_else_clause_opt_fina_clause of (
            except_clause list (* one or more *)
          * else_clause option
          * finally_clause option
        )
      | `Fina_clause of finally_clause
    ]
)
[@@deriving sexp_of]

type while_statement (* inlined *) = (
    Token.t (* "while" *)
  * type_
  * Token.t (* ":" *)
  * suite
  * else_clause option
)
[@@deriving sexp_of]

type with_statement (* inlined *) = (
    Token.t (* "async" *) option
  * Token.t (* "with" *)
  * with_clause
  * Token.t (* ":" *)
  * suite
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_module_ root
  |> Print_sexp.to_stdout
