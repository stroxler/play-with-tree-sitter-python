(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_python"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "string_end", None;
  "string_content", None;
  "integer", None;
  "ellipsis", None;
  "escape_interpolation",
  Some (
    Alt [|
      Token (Literal "{{");
      Token (Literal "}}");
    |];
  );
  "type_conversion", None;
  "escape_sequence", None;
  "identifier", None;
  "float", None;
  "newline", None;
  "dedent", None;
  "continue_statement", None;
  "string_start", None;
  "keyword_separator", None;
  "wildcard_import", None;
  "import_prefix",
  Some (
    Repeat1 (
      Token (Literal ".");
    );
  );
  "true", None;
  "break_statement", None;
  "none", None;
  "pass_statement", None;
  "positional_separator", None;
  "not_escape_sequence", None;
  "indent", None;
  "false", None;
  "global_statement",
  Some (
    Seq [
      Token (Literal "global");
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "dotted_name",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ".");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "nonlocal_statement",
  Some (
    Seq [
      Token (Literal "nonlocal");
      Token (Name "identifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "named_expresssion_lhs",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Literal "match");
    |];
  );
  "relative_import",
  Some (
    Seq [
      Token (Name "import_prefix");
      Opt (
        Token (Name "dotted_name");
      );
    ];
  );
  "aliased_import",
  Some (
    Seq [
      Token (Name "dotted_name");
      Token (Literal "as");
      Token (Name "identifier");
    ];
  );
  "argument_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Alt [|
            Token (Name "expression");
            Token (Name "list_splat");
            Token (Name "dictionary_splat");
            Token (Name "parenthesized_list_splat");
            Token (Name "keyword_argument");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "expression");
                Token (Name "list_splat");
                Token (Name "dictionary_splat");
                Token (Name "parenthesized_list_splat");
                Token (Name "keyword_argument");
              |];
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "as_pattern",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "as");
      Token (Name "expression");
    ];
  );
  "attribute",
  Some (
    Seq [
      Token (Name "primary_expression");
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "await",
  Some (
    Seq [
      Token (Literal "await");
      Token (Name "expression");
    ];
  );
  "binary_operator",
  Some (
    Alt [|
      Seq [
        Token (Name "primary_expression");
        Token (Literal "+");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "-");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "*");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "@");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "/");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "%");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "//");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "**");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "|");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "&");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "^");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal "<<");
        Token (Name "primary_expression");
      ];
      Seq [
        Token (Name "primary_expression");
        Token (Literal ">>");
        Token (Name "primary_expression");
      ];
    |];
  );
  "boolean_operator",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal "and");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "or");
        Token (Name "expression");
      ];
    |];
  );
  "call",
  Some (
    Seq [
      Token (Name "primary_expression");
      Alt [|
        Token (Name "generator_expression");
        Token (Name "argument_list");
      |];
    ];
  );
  "collection_elements",
  Some (
    Seq [
      Alt [|
        Token (Name "expression");
        Token (Name "yield");
        Token (Name "list_splat");
        Token (Name "parenthesized_list_splat");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "expression");
            Token (Name "yield");
            Token (Name "list_splat");
            Token (Name "parenthesized_list_splat");
          |];
        ];
      );
      Opt (
        Token (Literal ",");
      );
    ];
  );
  "comparison_operator",
  Some (
    Seq [
      Token (Name "primary_expression");
      Repeat1 (
        Seq [
          Alt [|
            Token (Literal "<");
            Token (Literal "<=");
            Token (Literal "==");
            Token (Literal "!=");
            Token (Literal ">=");
            Token (Literal ">");
            Token (Literal "<>");
            Token (Literal "in");
            Seq [
              Token (Literal "not");
              Token (Literal "in");
            ];
            Token (Literal "is");
            Seq [
              Token (Literal "is");
              Token (Literal "not");
            ];
          |];
          Token (Name "primary_expression");
        ];
      );
    ];
  );
  "comprehension_clauses",
  Some (
    Seq [
      Token (Name "for_in_clause");
      Repeat (
        Alt [|
          Token (Name "for_in_clause");
          Token (Name "if_clause");
        |];
      );
    ];
  );
  "concatenated_string",
  Some (
    Seq [
      Token (Name "string");
      Repeat1 (
        Token (Name "string");
      );
    ];
  );
  "conditional_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "if");
      Token (Name "expression");
      Token (Literal "else");
      Token (Name "expression");
    ];
  );
  "default_parameter",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "dictionary",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Alt [|
            Token (Name "pair");
            Token (Name "dictionary_splat");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "pair");
                Token (Name "dictionary_splat");
              |];
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "dictionary_comprehension",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "pair");
      Token (Name "comprehension_clauses");
      Token (Literal "}");
    ];
  );
  "dictionary_splat",
  Some (
    Seq [
      Token (Literal "**");
      Token (Name "expression");
    ];
  );
  "dictionary_splat_pattern",
  Some (
    Seq [
      Token (Literal "**");
      Alt [|
        Token (Name "identifier");
        Alt [|
          Token (Literal "print");
          Token (Literal "exec");
          Token (Literal "async");
          Token (Literal "await");
        |];
        Token (Name "subscript");
        Token (Name "attribute");
      |];
    ];
  );
  "expression",
  Some (
    Alt [|
      Token (Name "comparison_operator");
      Token (Name "not_operator");
      Token (Name "boolean_operator");
      Token (Name "await");
      Token (Name "lambda");
      Token (Name "primary_expression");
      Token (Name "conditional_expression");
      Token (Name "named_expression");
      Token (Name "as_pattern");
    |];
  );
  "expression_list",
  Some (
    Seq [
      Token (Name "expression");
      Alt [|
        Token (Literal ",");
        Seq [
          Repeat1 (
            Seq [
              Token (Literal ",");
              Token (Name "expression");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      |];
    ];
  );
  "expression_within_for_in_clause",
  Some (
    Alt [|
      Token (Name "expression");
      Token (Name "lambda_within_for_in_clause");
    |];
  );
  "for_in_clause",
  Some (
    Seq [
      Opt (
        Token (Literal "async");
      );
      Token (Literal "for");
      Alt [|
        Token (Name "pattern");
        Token (Name "pattern_list");
      |];
      Token (Literal "in");
      Token (Name "expression_within_for_in_clause");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expression_within_for_in_clause");
        ];
      );
      Opt (
        Token (Literal ",");
      );
    ];
  );
  "format_expression",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "expression");
      Token (Literal "}");
    ];
  );
  "format_specifier",
  Some (
    Seq [
      Token (Literal ":");
      Repeat (
        Alt [|
          Token (Literal "[^{}\\n]+");
          Token (Name "format_expression");
        |];
      );
    ];
  );
  "generator_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Name "comprehension_clauses");
      Token (Literal ")");
    ];
  );
  "if_clause",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "expression");
    ];
  );
  "interpolation",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "expression");
      Opt (
        Token (Literal "=");
      );
      Opt (
        Token (Name "type_conversion");
      );
      Opt (
        Token (Name "format_specifier");
      );
      Token (Literal "}");
    ];
  );
  "keyword_argument",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Alt [|
          Token (Literal "print");
          Token (Literal "exec");
          Token (Literal "async");
          Token (Literal "await");
        |];
        Token (Literal "match");
      |];
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "lambda",
  Some (
    Seq [
      Token (Literal "lambda");
      Opt (
        Token (Name "lambda_parameters");
      );
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "lambda_parameters", Some (Token (Name "parameters_"););
  "lambda_within_for_in_clause",
  Some (
    Seq [
      Token (Literal "lambda");
      Opt (
        Token (Name "lambda_parameters");
      );
      Token (Literal ":");
      Token (Name "expression_within_for_in_clause");
    ];
  );
  "list",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Token (Name "collection_elements");
      );
      Token (Literal "]");
    ];
  );
  "list_comprehension",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "expression");
      Token (Name "comprehension_clauses");
      Token (Literal "]");
    ];
  );
  "list_pattern",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Token (Name "patterns");
      );
      Token (Literal "]");
    ];
  );
  "list_splat",
  Some (
    Seq [
      Token (Literal "*");
      Token (Name "expression");
    ];
  );
  "list_splat_pattern",
  Some (
    Seq [
      Token (Literal "*");
      Alt [|
        Token (Name "identifier");
        Alt [|
          Token (Literal "print");
          Token (Literal "exec");
          Token (Literal "async");
          Token (Literal "await");
        |];
        Token (Name "subscript");
        Token (Name "attribute");
      |];
    ];
  );
  "named_expression",
  Some (
    Seq [
      Token (Name "named_expresssion_lhs");
      Token (Literal ":=");
      Token (Name "expression");
    ];
  );
  "not_operator",
  Some (
    Seq [
      Token (Literal "not");
      Token (Name "expression");
    ];
  );
  "pair",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "parameter",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Name "typed_parameter");
      Token (Name "default_parameter");
      Token (Name "typed_default_parameter");
      Token (Name "list_splat_pattern");
      Token (Name "tuple_pattern");
      Token (Name "keyword_separator");
      Token (Name "positional_separator");
      Token (Name "dictionary_splat_pattern");
    |];
  );
  "parameters_",
  Some (
    Seq [
      Token (Name "parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "parameter");
        ];
      );
      Opt (
        Token (Literal ",");
      );
    ];
  );
  "parenthesized_expression",
  Some (
    Seq [
      Token (Literal "(");
      Alt [|
        Token (Name "expression");
        Token (Name "yield");
      |];
      Token (Literal ")");
    ];
  );
  "parenthesized_list_splat",
  Some (
    Seq [
      Token (Literal "(");
      Alt [|
        Token (Name "parenthesized_list_splat");
        Token (Name "list_splat");
      |];
      Token (Literal ")");
    ];
  );
  "pattern",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Literal "match");
      Alt [|
        Token (Literal "print");
        Token (Literal "exec");
        Token (Literal "async");
        Token (Literal "await");
      |];
      Token (Name "subscript");
      Token (Name "attribute");
      Token (Name "list_splat_pattern");
      Token (Name "tuple_pattern");
      Token (Name "list_pattern");
    |];
  );
  "pattern_list",
  Some (
    Seq [
      Token (Name "pattern");
      Alt [|
        Token (Literal ",");
        Seq [
          Repeat1 (
            Seq [
              Token (Literal ",");
              Token (Name "pattern");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      |];
    ];
  );
  "patterns",
  Some (
    Seq [
      Token (Name "pattern");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "pattern");
        ];
      );
      Opt (
        Token (Literal ",");
      );
    ];
  );
  "primary_expression",
  Some (
    Alt [|
      Token (Name "binary_operator");
      Token (Name "identifier");
      Token (Literal "match");
      Alt [|
        Token (Literal "print");
        Token (Literal "exec");
        Token (Literal "async");
        Token (Literal "await");
      |];
      Token (Name "string");
      Token (Name "concatenated_string");
      Token (Name "integer");
      Token (Name "float");
      Token (Name "true");
      Token (Name "false");
      Token (Name "none");
      Token (Name "unary_operator");
      Token (Name "attribute");
      Token (Name "subscript");
      Token (Name "call");
      Token (Name "list");
      Token (Name "list_comprehension");
      Token (Name "dictionary");
      Token (Name "dictionary_comprehension");
      Token (Name "set");
      Token (Name "set_comprehension");
      Token (Name "tuple");
      Token (Name "parenthesized_expression");
      Token (Name "generator_expression");
      Token (Name "ellipsis");
    |];
  );
  "set",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "collection_elements");
      Token (Literal "}");
    ];
  );
  "set_comprehension",
  Some (
    Seq [
      Token (Literal "{");
      Token (Name "expression");
      Token (Name "comprehension_clauses");
      Token (Literal "}");
    ];
  );
  "slice",
  Some (
    Seq [
      Opt (
        Token (Name "expression");
      );
      Token (Literal ":");
      Opt (
        Token (Name "expression");
      );
      Opt (
        Seq [
          Token (Literal ":");
          Opt (
            Token (Name "expression");
          );
        ];
      );
    ];
  );
  "string",
  Some (
    Seq [
      Token (Name "string_start");
      Repeat (
        Alt [|
          Token (Name "interpolation");
          Token (Name "escape_interpolation");
          Token (Name "escape_sequence");
          Token (Name "not_escape_sequence");
          Token (Name "string_content");
        |];
      );
      Token (Name "string_end");
    ];
  );
  "subscript",
  Some (
    Seq [
      Token (Name "primary_expression");
      Token (Literal "[");
      Alt [|
        Token (Name "expression");
        Token (Name "slice");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "expression");
            Token (Name "slice");
          |];
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
    ];
  );
  "tuple",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Token (Name "collection_elements");
      );
      Token (Literal ")");
    ];
  );
  "tuple_pattern",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Token (Name "patterns");
      );
      Token (Literal ")");
    ];
  );
  "type", Some (Token (Name "expression"););
  "typed_default_parameter",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal ":");
      Token (Name "type");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "typed_parameter",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "list_splat_pattern");
        Token (Name "dictionary_splat_pattern");
      |];
      Token (Literal ":");
      Token (Name "type");
    ];
  );
  "unary_operator",
  Some (
    Seq [
      Alt [|
        Token (Literal "+");
        Token (Literal "-");
        Token (Literal "~");
      |];
      Token (Name "primary_expression");
    ];
  );
  "yield",
  Some (
    Seq [
      Token (Literal "yield");
      Alt [|
        Seq [
          Token (Literal "from");
          Token (Name "expression");
        ];
        Opt (
          Alt [|
            Token (Name "expression");
            Token (Name "expression_list");
          |];
        );
      |];
    ];
  );
  "import_list",
  Some (
    Seq [
      Alt [|
        Token (Name "dotted_name");
        Token (Name "aliased_import");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "dotted_name");
            Token (Name "aliased_import");
          |];
        ];
      );
      Opt (
        Token (Literal ",");
      );
    ];
  );
  "delete_statement",
  Some (
    Seq [
      Token (Literal "del");
      Alt [|
        Token (Name "expression");
        Token (Name "expression_list");
      |];
    ];
  );
  "assignment",
  Some (
    Seq [
      Alt [|
        Token (Name "pattern");
        Token (Name "pattern_list");
      |];
      Alt [|
        Seq [
          Token (Literal "=");
          Token (Name "right_hand_side");
        ];
        Seq [
          Token (Literal ":");
          Token (Name "type");
        ];
        Seq [
          Token (Literal ":");
          Token (Name "type");
          Token (Literal "=");
          Token (Name "right_hand_side");
        ];
      |];
    ];
  );
  "augmented_assignment",
  Some (
    Seq [
      Alt [|
        Token (Name "pattern");
        Token (Name "pattern_list");
      |];
      Alt [|
        Token (Literal "+=");
        Token (Literal "-=");
        Token (Literal "*=");
        Token (Literal "/=");
        Token (Literal "@=");
        Token (Literal "//=");
        Token (Literal "%=");
        Token (Literal "**=");
        Token (Literal ">>=");
        Token (Literal "<<=");
        Token (Literal "&=");
        Token (Literal "^=");
        Token (Literal "|=");
      |];
      Token (Name "right_hand_side");
    ];
  );
  "right_hand_side",
  Some (
    Alt [|
      Token (Name "expression");
      Token (Name "expression_list");
      Token (Name "assignment");
      Token (Name "augmented_assignment");
      Token (Name "yield");
    |];
  );
  "with_item",
  Some (
    Seq [
      Token (Name "expression");
    ];
  );
  "exec_statement",
  Some (
    Seq [
      Token (Literal "exec");
      Token (Name "string");
      Opt (
        Seq [
          Token (Literal "in");
          Token (Name "expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expression");
            ];
          );
        ];
      );
    ];
  );
  "parameters",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Token (Name "parameters_");
      );
      Token (Literal ")");
    ];
  );
  "chevron",
  Some (
    Seq [
      Token (Literal ">>");
      Token (Name "expression");
    ];
  );
  "raise_statement",
  Some (
    Seq [
      Token (Literal "raise");
      Opt (
        Alt [|
          Token (Name "expression");
          Token (Name "expression_list");
        |];
      );
      Opt (
        Seq [
          Token (Literal "from");
          Token (Name "expression");
        ];
      );
    ];
  );
  "decorator",
  Some (
    Seq [
      Token (Literal "@");
      Token (Name "primary_expression");
      Token (Name "newline");
    ];
  );
  "return_statement",
  Some (
    Seq [
      Token (Literal "return");
      Opt (
        Alt [|
          Token (Name "expression");
          Token (Name "expression_list");
        |];
      );
    ];
  );
  "assert_statement",
  Some (
    Seq [
      Token (Literal "assert");
      Token (Name "expression");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expression");
        ];
      );
    ];
  );
  "import_from_statement",
  Some (
    Seq [
      Token (Literal "from");
      Alt [|
        Token (Name "relative_import");
        Token (Name "dotted_name");
      |];
      Token (Literal "import");
      Alt [|
        Token (Name "wildcard_import");
        Token (Name "import_list");
        Seq [
          Token (Literal "(");
          Token (Name "import_list");
          Token (Literal ")");
        ];
      |];
    ];
  );
  "future_import_statement",
  Some (
    Seq [
      Token (Literal "from");
      Token (Literal "__future__");
      Token (Literal "import");
      Alt [|
        Token (Name "import_list");
        Seq [
          Token (Literal "(");
          Token (Name "import_list");
          Token (Literal ")");
        ];
      |];
    ];
  );
  "import_statement",
  Some (
    Seq [
      Token (Literal "import");
      Token (Name "import_list");
    ];
  );
  "expression_statement",
  Some (
    Alt [|
      Token (Name "expression");
      Seq [
        Token (Name "expression");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "expression");
          ];
        );
        Opt (
          Token (Literal ",");
        );
      ];
      Token (Name "assignment");
      Token (Name "augmented_assignment");
      Token (Name "yield");
    |];
  );
  "with_clause",
  Some (
    Alt [|
      Seq [
        Token (Name "with_item");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "with_item");
          ];
        );
      ];
      Seq [
        Token (Literal "(");
        Token (Name "with_item");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "with_item");
          ];
        );
        Token (Literal ")");
      ];
    |];
  );
  "print_statement",
  Some (
    Alt [|
      Seq [
        Token (Literal "print");
        Token (Name "chevron");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "expression");
          ];
        );
        Opt (
          Token (Literal ",");
        );
      ];
      Seq [
        Token (Literal "print");
        Token (Name "expression");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "expression");
          ];
        );
        Opt (
          Token (Literal ",");
        );
      ];
    |];
  );
  "simple_statements",
  Some (
    Seq [
      Alt [|
        Token (Name "future_import_statement");
        Token (Name "import_statement");
        Token (Name "import_from_statement");
        Token (Name "print_statement");
        Token (Name "assert_statement");
        Token (Name "expression_statement");
        Token (Name "return_statement");
        Token (Name "delete_statement");
        Token (Name "raise_statement");
        Token (Name "pass_statement");
        Token (Name "break_statement");
        Token (Name "continue_statement");
        Token (Name "global_statement");
        Token (Name "nonlocal_statement");
        Token (Name "exec_statement");
      |];
      Repeat (
        Seq [
          Token (Literal ";");
          Alt [|
            Token (Name "future_import_statement");
            Token (Name "import_statement");
            Token (Name "import_from_statement");
            Token (Name "print_statement");
            Token (Name "assert_statement");
            Token (Name "expression_statement");
            Token (Name "return_statement");
            Token (Name "delete_statement");
            Token (Name "raise_statement");
            Token (Name "pass_statement");
            Token (Name "break_statement");
            Token (Name "continue_statement");
            Token (Name "global_statement");
            Token (Name "nonlocal_statement");
            Token (Name "exec_statement");
          |];
        ];
      );
      Opt (
        Token (Literal ";");
      );
      Token (Name "newline");
    ];
  );
  "block",
  Some (
    Seq [
      Repeat (
        Token (Name "statement");
      );
      Token (Name "dedent");
    ];
  );
  "case_clause",
  Some (
    Seq [
      Token (Literal "case");
      Alt [|
        Token (Name "expression");
        Token (Name "list_splat_pattern");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "expression");
            Token (Name "list_splat_pattern");
          |];
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Opt (
        Token (Name "if_clause");
      );
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
    ];
  );
  "class_definition",
  Some (
    Seq [
      Token (Literal "class");
      Token (Name "identifier");
      Opt (
        Token (Name "argument_list");
      );
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
    ];
  );
  "decorated_definition",
  Some (
    Seq [
      Repeat1 (
        Token (Name "decorator");
      );
      Alt [|
        Token (Name "class_definition");
        Token (Name "function_definition");
      |];
    ];
  );
  "elif_clause",
  Some (
    Seq [
      Token (Literal "elif");
      Token (Name "expression");
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
    ];
  );
  "else_clause",
  Some (
    Seq [
      Token (Literal "else");
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
    ];
  );
  "except_clause",
  Some (
    Seq [
      Token (Literal "except");
      Opt (
        Seq [
          Token (Name "expression");
          Opt (
            Seq [
              Alt [|
                Token (Literal "as");
                Token (Literal ",");
              |];
              Token (Name "expression");
            ];
          );
        ];
      );
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
    ];
  );
  "finally_clause",
  Some (
    Seq [
      Token (Literal "finally");
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
    ];
  );
  "for_statement",
  Some (
    Seq [
      Opt (
        Token (Literal "async");
      );
      Token (Literal "for");
      Alt [|
        Token (Name "pattern");
        Token (Name "pattern_list");
      |];
      Token (Literal "in");
      Alt [|
        Token (Name "expression");
        Token (Name "expression_list");
      |];
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
      Opt (
        Token (Name "else_clause");
      );
    ];
  );
  "function_definition",
  Some (
    Seq [
      Opt (
        Token (Literal "async");
      );
      Token (Literal "def");
      Token (Name "identifier");
      Token (Name "parameters");
      Opt (
        Seq [
          Token (Literal "->");
          Token (Name "type");
        ];
      );
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
    ];
  );
  "if_statement",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "expression");
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
      Repeat (
        Token (Name "elif_clause");
      );
      Opt (
        Token (Name "else_clause");
      );
    ];
  );
  "match_statement",
  Some (
    Seq [
      Token (Literal "match");
      Token (Name "expression");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expression");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ":");
      Repeat (
        Token (Name "case_clause");
      );
    ];
  );
  "statement",
  Some (
    Alt [|
      Token (Name "simple_statements");
      Alt [|
        Token (Name "if_statement");
        Token (Name "for_statement");
        Token (Name "while_statement");
        Token (Name "try_statement");
        Token (Name "with_statement");
        Token (Name "function_definition");
        Token (Name "class_definition");
        Token (Name "decorated_definition");
        Token (Name "match_statement");
      |];
    |];
  );
  "try_statement",
  Some (
    Seq [
      Token (Literal "try");
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
      Alt [|
        Seq [
          Repeat1 (
            Token (Name "except_clause");
          );
          Opt (
            Token (Name "else_clause");
          );
          Opt (
            Token (Name "finally_clause");
          );
        ];
        Token (Name "finally_clause");
      |];
    ];
  );
  "while_statement",
  Some (
    Seq [
      Token (Literal "while");
      Token (Name "expression");
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
      Opt (
        Token (Name "else_clause");
      );
    ];
  );
  "with_statement",
  Some (
    Seq [
      Opt (
        Token (Literal "async");
      );
      Token (Literal "with");
      Token (Name "with_clause");
      Token (Literal ":");
      Alt [|
        Token (Name "simple_statements");
        Seq [
          Token (Name "indent");
          Token (Name "block");
        ];
        Token (Name "newline");
      |];
    ];
  );
  "module",
  Some (
    Repeat (
      Token (Name "statement");
    );
  );
]

let trans_string_end ((kind, body) : mt) : CST.string_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_content ((kind, body) : mt) : CST.string_content =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_integer ((kind, body) : mt) : CST.integer =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_ellipsis ((kind, body) : mt) : CST.ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape_interpolation ((kind, body) : mt) : CST.escape_interpolation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LCURLLCURL (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `RCURLRCURL (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_type_conversion ((kind, body) : mt) : CST.type_conversion =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_float_ ((kind, body) : mt) : CST.float_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_newline ((kind, body) : mt) : CST.newline =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_dedent ((kind, body) : mt) : CST.dedent =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_continue_statement ((kind, body) : mt) : CST.continue_statement =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_start ((kind, body) : mt) : CST.string_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_keyword_separator ((kind, body) : mt) : CST.keyword_separator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_wildcard_import ((kind, body) : mt) : CST.wildcard_import =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_import_prefix ((kind, body) : mt) : CST.import_prefix =
  match body with
  | Children v ->
      Run.repeat1
        (fun v -> Run.trans_token (Run.matcher_token v))
        v
  | Leaf _ -> assert false

let trans_true_ ((kind, body) : mt) : CST.true_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_break_statement ((kind, body) : mt) : CST.break_statement =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_none ((kind, body) : mt) : CST.none =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pass_statement ((kind, body) : mt) : CST.pass_statement =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_positional_separator ((kind, body) : mt) : CST.positional_separator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_not_escape_sequence ((kind, body) : mt) : CST.not_escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_indent ((kind, body) : mt) : CST.indent =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_false_ ((kind, body) : mt) : CST.false_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_global_statement ((kind, body) : mt) : CST.global_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_dotted_name ((kind, body) : mt) : CST.dotted_name =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_nonlocal_statement ((kind, body) : mt) : CST.nonlocal_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_named_expresssion_lhs ((kind, body) : mt) : CST.named_expresssion_lhs =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Match (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_relative_import ((kind, body) : mt) : CST.relative_import =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_import_prefix (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_dotted_name (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_aliased_import ((kind, body) : mt) : CST.aliased_import =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_dotted_name (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_argument_list ((kind, body) : mt) : CST.argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `List_splat (
                            trans_list_splat (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Dict_splat (
                            trans_dictionary_splat (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `Paren_list_splat (
                            trans_parenthesized_list_splat (Run.matcher_token v)
                          )
                      | Alt (4, v) ->
                          `Kw_arg (
                            trans_keyword_argument (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Exp (
                                      trans_expression (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `List_splat (
                                      trans_list_splat (Run.matcher_token v)
                                    )
                                | Alt (2, v) ->
                                    `Dict_splat (
                                      trans_dictionary_splat (Run.matcher_token v)
                                    )
                                | Alt (3, v) ->
                                    `Paren_list_splat (
                                      trans_parenthesized_list_splat (Run.matcher_token v)
                                    )
                                | Alt (4, v) ->
                                    `Kw_arg (
                                      trans_keyword_argument (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_as_pattern ((kind, body) : mt) : CST.as_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_attribute ((kind, body) : mt) : CST.attribute =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_primary_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_await ((kind, body) : mt) : CST.await =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_operator ((kind, body) : mt) : CST.binary_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Prim_exp_PLUS_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Prim_exp_DASH_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Prim_exp_STAR_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Prim_exp_AT_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Prim_exp_SLASH_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Prim_exp_PERC_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Prim_exp_SLASHSLASH_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Prim_exp_STARSTAR_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Prim_exp_BAR_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Prim_exp_AMP_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Prim_exp_HAT_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Prim_exp_LTLT_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Prim_exp_GTGT_prim_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_primary_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_primary_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_boolean_operator ((kind, body) : mt) : CST.boolean_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_and_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_or_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call ((kind, body) : mt) : CST.call =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_primary_expression (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Gene_exp (
                  trans_generator_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Arg_list (
                  trans_argument_list (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_collection_elements ((kind, body) : mt) : CST.collection_elements =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Yield (
                  trans_yield (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `List_splat (
                  trans_list_splat (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Paren_list_splat (
                  trans_parenthesized_list_splat (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Yield (
                            trans_yield (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `List_splat (
                            trans_list_splat (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `Paren_list_splat (
                            trans_parenthesized_list_splat (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_comparison_operator ((kind, body) : mt) : CST.comparison_operator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_primary_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `LT (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `LTEQ (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `EQEQ (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `BANGEQ (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (4, v) ->
                          `GTEQ (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (5, v) ->
                          `GT (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (6, v) ->
                          `LTGT (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (7, v) ->
                          `In (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (8, v) ->
                          `Not_in (
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  Run.trans_token (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                      | Alt (9, v) ->
                          `Is (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (10, v) ->
                          `Is_not (
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  Run.trans_token (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                      ,
                      trans_primary_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_comprehension_clauses ((kind, body) : mt) : CST.comprehension_clauses =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_for_in_clause (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `For_in_clause (
                      trans_for_in_clause (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `If_clause (
                      trans_if_clause (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_concatenated_string ((kind, body) : mt) : CST.concatenated_string =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_string_ (Run.matcher_token v0),
            Run.repeat1
              (fun v -> trans_string_ (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_conditional_expression ((kind, body) : mt) : CST.conditional_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_default_parameter ((kind, body) : mt) : CST.default_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dictionary ((kind, body) : mt) : CST.dictionary =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Pair (
                            trans_pair (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Dict_splat (
                            trans_dictionary_splat (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Pair (
                                      trans_pair (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Dict_splat (
                                      trans_dictionary_splat (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dictionary_comprehension ((kind, body) : mt) : CST.dictionary_comprehension =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pair (Run.matcher_token v1),
            trans_comprehension_clauses (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dictionary_splat ((kind, body) : mt) : CST.dictionary_splat =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dictionary_splat_pattern ((kind, body) : mt) : CST.dictionary_splat_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_print (
                  (match v with
                  | Alt (0, v) ->
                      `Print (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Exec (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Async (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `Await (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Subs (
                  trans_subscript (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Attr (
                  trans_attribute (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Comp_op (
            trans_comparison_operator (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Not_op (
            trans_not_operator (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Bool_op (
            trans_boolean_operator (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Await (
            trans_await (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Lambda (
            trans_lambda (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Prim_exp (
            trans_primary_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Cond_exp (
            trans_conditional_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Named_exp (
            trans_named_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `As_pat (
            trans_as_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression_list ((kind, body) : mt) : CST.expression_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `COMMA (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Rep1_COMMA_exp_opt_COMMA (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.repeat1
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_expression (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v0
                        ,
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression_within_for_in_clause ((kind, body) : mt) : CST.expression_within_for_in_clause =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Lambda_within_for_in_clause (
            trans_lambda_within_for_in_clause (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_in_clause ((kind, body) : mt) : CST.for_in_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Pat (
                  trans_pattern (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Pat_list (
                  trans_pattern_list (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_expression_within_for_in_clause (Run.matcher_token v4)
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression_within_for_in_clause (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v6
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_format_expression ((kind, body) : mt) : CST.format_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_format_specifier ((kind, body) : mt) : CST.format_specifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `LBRA (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Format_exp (
                      trans_format_expression (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_generator_expression ((kind, body) : mt) : CST.generator_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            trans_comprehension_clauses (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_clause ((kind, body) : mt) : CST.if_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interpolation ((kind, body) : mt) : CST.interpolation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_type_conversion (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_format_specifier (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_keyword_argument ((kind, body) : mt) : CST.keyword_argument =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_print (
                  (match v with
                  | Alt (0, v) ->
                      `Print (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Exec (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Async (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `Await (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Match (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lambda ((kind, body) : mt) : CST.lambda =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_lambda_parameters (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lambda_parameters ((kind, body) : mt) : CST.lambda_parameters =
  match body with
  | Children v ->
      trans_parameters_ (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_lambda_within_for_in_clause ((kind, body) : mt) : CST.lambda_within_for_in_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_lambda_parameters (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_expression_within_for_in_clause (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_list_ ((kind, body) : mt) : CST.list_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_collection_elements (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_list_comprehension ((kind, body) : mt) : CST.list_comprehension =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            trans_comprehension_clauses (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_list_pattern ((kind, body) : mt) : CST.list_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_patterns (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_list_splat ((kind, body) : mt) : CST.list_splat =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_list_splat_pattern ((kind, body) : mt) : CST.list_splat_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_print (
                  (match v with
                  | Alt (0, v) ->
                      `Print (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Exec (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Async (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `Await (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Subs (
                  trans_subscript (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Attr (
                  trans_attribute (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_named_expression ((kind, body) : mt) : CST.named_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_named_expresssion_lhs (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_not_operator ((kind, body) : mt) : CST.not_operator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pair ((kind, body) : mt) : CST.pair =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameter ((kind, body) : mt) : CST.parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Typed_param (
            trans_typed_parameter (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Defa_param (
            trans_default_parameter (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Typed_defa_param (
            trans_typed_default_parameter (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `List_splat_pat (
            trans_list_splat_pattern (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Tuple_pat (
            trans_tuple_pattern (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Kw_sepa (
            trans_keyword_separator (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Posi_sepa (
            trans_positional_separator (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Dict_splat_pat (
            trans_dictionary_splat_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameters_ ((kind, body) : mt) : CST.parameters_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_parameter (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_expression ((kind, body) : mt) : CST.parenthesized_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Yield (
                  trans_yield (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_list_splat ((kind, body) : mt) : CST.parenthesized_list_splat =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Paren_list_splat (
                  trans_parenthesized_list_splat (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `List_splat (
                  trans_list_splat (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pattern ((kind, body) : mt) : CST.pattern =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Match (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Choice_print (
            (match v with
            | Alt (0, v) ->
                `Print (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Exec (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Async (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Await (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Subs (
            trans_subscript (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Attr (
            trans_attribute (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `List_splat_pat (
            trans_list_splat_pattern (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Tuple_pat (
            trans_tuple_pattern (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `List_pat (
            trans_list_pattern (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pattern_list ((kind, body) : mt) : CST.pattern_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pattern (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `COMMA (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Rep1_COMMA_pat_opt_COMMA (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.repeat1
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_pattern (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v0
                        ,
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_patterns ((kind, body) : mt) : CST.patterns =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pattern (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_pattern (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primary_expression ((kind, body) : mt) : CST.primary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bin_op (
            trans_binary_operator (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Match (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Choice_print (
            (match v with
            | Alt (0, v) ->
                `Print (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Exec (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Async (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Await (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Str (
            trans_string_ (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Conc_str (
            trans_concatenated_string (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Int (
            trans_integer (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Float (
            trans_float_ (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `True (
            trans_true_ (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `False (
            trans_false_ (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `None (
            trans_none (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Un_op (
            trans_unary_operator (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Attr (
            trans_attribute (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Subs (
            trans_subscript (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Call (
            trans_call (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `List (
            trans_list_ (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `List_comp (
            trans_list_comprehension (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Dict (
            trans_dictionary (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Dict_comp (
            trans_dictionary_comprehension (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Set (
            trans_set (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Set_comp (
            trans_set_comprehension (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Tuple (
            trans_tuple (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `Paren_exp (
            trans_parenthesized_expression (Run.matcher_token v)
          )
      | Alt (23, v) ->
          `Gene_exp (
            trans_generator_expression (Run.matcher_token v)
          )
      | Alt (24, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_set ((kind, body) : mt) : CST.set =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_collection_elements (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_set_comprehension ((kind, body) : mt) : CST.set_comprehension =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            trans_comprehension_clauses (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_slice ((kind, body) : mt) : CST.slice =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.opt
                        (fun v -> trans_expression (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_ ((kind, body) : mt) : CST.string_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_string_start (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Interp (
                      trans_interpolation (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Esc_interp (
                      trans_escape_interpolation (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Not_esc_seq (
                      trans_not_escape_sequence (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Str_content (
                      trans_string_content (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_string_end (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_subscript ((kind, body) : mt) : CST.subscript =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            trans_primary_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Slice (
                  trans_slice (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Slice (
                            trans_slice (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple ((kind, body) : mt) : CST.tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_collection_elements (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple_pattern ((kind, body) : mt) : CST.tuple_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_patterns (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      trans_expression (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_typed_default_parameter ((kind, body) : mt) : CST.typed_default_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_typed_parameter ((kind, body) : mt) : CST.typed_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `List_splat_pat (
                  trans_list_splat_pattern (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Dict_splat_pat (
                  trans_dictionary_splat_pattern (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_operator ((kind, body) : mt) : CST.unary_operator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `PLUS (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `DASH (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `TILDE (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_primary_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_yield ((kind, body) : mt) : CST.yield =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `From_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Opt_choice_exp (
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Exp_list (
                            trans_expression_list (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_list ((kind, body) : mt) : CST.import_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Dotted_name (
                  trans_dotted_name (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Alia_import (
                  trans_aliased_import (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Dotted_name (
                            trans_dotted_name (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Alia_import (
                            trans_aliased_import (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_delete_statement ((kind, body) : mt) : CST.delete_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Exp_list (
                  trans_expression_list (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_assignment ((kind, body) : mt) : CST.assignment =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Pat (
                  trans_pattern (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Pat_list (
                  trans_pattern_list (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `EQ_right_hand_side (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_right_hand_side (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `COLON_type (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_type_ (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `COLON_type_EQ_right_hand_side (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_type_ (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2),
                        trans_right_hand_side (Run.matcher_token v3)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_augmented_assignment ((kind, body) : mt) : CST.augmented_assignment =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Pat (
                  trans_pattern (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Pat_list (
                  trans_pattern_list (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `PLUSEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `DASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `STAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `SLASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `ATEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `SLASHSLASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `PERCEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `STARSTAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `GTGTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `LTLTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `AMPEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (11, v) ->
                `HATEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (12, v) ->
                `BAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_right_hand_side (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_right_hand_side ((kind, body) : mt) : CST.right_hand_side =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Exp_list (
            trans_expression_list (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Assign (
            trans_assignment (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Augm_assign (
            trans_augmented_assignment (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Yield (
            trans_yield (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_item ((kind, body) : mt) : CST.with_item =
  match body with
  | Children v ->
      (match v with
      | Seq [v0] ->
          (trans_expression (Run.matcher_token v0))
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_exec_statement ((kind, body) : mt) : CST.exec_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_string_ (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_expression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_parameters ((kind, body) : mt) : CST.parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_parameters_ (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_chevron ((kind, body) : mt) : CST.chevron =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_raise_statement ((kind, body) : mt) : CST.raise_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Exp (
                      trans_expression (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Exp_list (
                      trans_expression_list (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_decorator ((kind, body) : mt) : CST.decorator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_primary_expression (Run.matcher_token v1),
            trans_newline (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_return_statement ((kind, body) : mt) : CST.return_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Exp (
                      trans_expression (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Exp_list (
                      trans_expression_list (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_assert_statement ((kind, body) : mt) : CST.assert_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_from_statement ((kind, body) : mt) : CST.import_from_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Rela_import (
                  trans_relative_import (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Dotted_name (
                  trans_dotted_name (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Wild_import (
                  trans_wildcard_import (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Import_list (
                  trans_import_list (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `LPAR_import_list_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_import_list (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_future_import_statement ((kind, body) : mt) : CST.future_import_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Import_list (
                  trans_import_list (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_import_list_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_import_list (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_statement ((kind, body) : mt) : CST.import_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_import_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_expression_statement ((kind, body) : mt) : CST.expression_statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Exp_rep_COMMA_exp_opt_COMMA (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Assign (
            trans_assignment (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Augm_assign (
            trans_augmented_assignment (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Yield (
            trans_yield (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_clause ((kind, body) : mt) : CST.with_clause =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `With_item_rep_COMMA_with_item (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_with_item (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_with_item (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `LPAR_with_item_rep_COMMA_with_item_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_with_item (Run.matcher_token v1),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_with_item (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_print_statement ((kind, body) : mt) : CST.print_statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Print_chev_rep_COMMA_exp_opt_COMMA (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_chevron (Run.matcher_token v1),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v3
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Print_exp_rep_COMMA_exp_opt_COMMA (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v3
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_simple_statements ((kind, body) : mt) : CST.simple_statements =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Future_import_stmt (
                  trans_future_import_statement (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Import_stmt (
                  trans_import_statement (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Import_from_stmt (
                  trans_import_from_statement (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Print_stmt (
                  trans_print_statement (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Assert_stmt (
                  trans_assert_statement (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Exp_stmt (
                  trans_expression_statement (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Ret_stmt (
                  trans_return_statement (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Delete_stmt (
                  trans_delete_statement (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `Raise_stmt (
                  trans_raise_statement (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `Pass_stmt (
                  trans_pass_statement (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `Brk_stmt (
                  trans_break_statement (Run.matcher_token v)
                )
            | Alt (11, v) ->
                `Cont_stmt (
                  trans_continue_statement (Run.matcher_token v)
                )
            | Alt (12, v) ->
                `Global_stmt (
                  trans_global_statement (Run.matcher_token v)
                )
            | Alt (13, v) ->
                `Nonl_stmt (
                  trans_nonlocal_statement (Run.matcher_token v)
                )
            | Alt (14, v) ->
                `Exec_stmt (
                  trans_exec_statement (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Future_import_stmt (
                            trans_future_import_statement (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Import_stmt (
                            trans_import_statement (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Import_from_stmt (
                            trans_import_from_statement (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `Print_stmt (
                            trans_print_statement (Run.matcher_token v)
                          )
                      | Alt (4, v) ->
                          `Assert_stmt (
                            trans_assert_statement (Run.matcher_token v)
                          )
                      | Alt (5, v) ->
                          `Exp_stmt (
                            trans_expression_statement (Run.matcher_token v)
                          )
                      | Alt (6, v) ->
                          `Ret_stmt (
                            trans_return_statement (Run.matcher_token v)
                          )
                      | Alt (7, v) ->
                          `Delete_stmt (
                            trans_delete_statement (Run.matcher_token v)
                          )
                      | Alt (8, v) ->
                          `Raise_stmt (
                            trans_raise_statement (Run.matcher_token v)
                          )
                      | Alt (9, v) ->
                          `Pass_stmt (
                            trans_pass_statement (Run.matcher_token v)
                          )
                      | Alt (10, v) ->
                          `Brk_stmt (
                            trans_break_statement (Run.matcher_token v)
                          )
                      | Alt (11, v) ->
                          `Cont_stmt (
                            trans_continue_statement (Run.matcher_token v)
                          )
                      | Alt (12, v) ->
                          `Global_stmt (
                            trans_global_statement (Run.matcher_token v)
                          )
                      | Alt (13, v) ->
                          `Nonl_stmt (
                            trans_nonlocal_statement (Run.matcher_token v)
                          )
                      | Alt (14, v) ->
                          `Exec_stmt (
                            trans_exec_statement (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            trans_newline (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let rec trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v0
            ,
            trans_dedent (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_case_clause ((kind, body) : mt) : CST.case_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `List_splat_pat (
                  trans_list_splat_pattern (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `List_splat_pat (
                            trans_list_splat_pattern (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_if_clause (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5),
            (match v6 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_definition ((kind, body) : mt) : CST.class_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_argument_list (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            (match v4 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_decorated_definition ((kind, body) : mt) : CST.decorated_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v -> trans_decorator (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Class_defi (
                  trans_class_definition (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Func_defi (
                  trans_function_definition (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_elif_clause ((kind, body) : mt) : CST.elif_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_else_clause ((kind, body) : mt) : CST.else_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_except_clause ((kind, body) : mt) : CST.except_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                (match v0 with
                                | Alt (0, v) ->
                                    `As (
                                      Run.trans_token (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `COMMA (
                                      Run.trans_token (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                                ,
                                trans_expression (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_finally_clause ((kind, body) : mt) : CST.finally_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_statement ((kind, body) : mt) : CST.for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Pat (
                  trans_pattern (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Pat_list (
                  trans_pattern_list (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3),
            (match v4 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Exp_list (
                  trans_expression_list (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v5),
            (match v6 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_else_clause (Run.matcher_token v))
              v7
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_definition ((kind, body) : mt) : CST.function_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            trans_parameters (Run.matcher_token v3),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.trans_token (Run.matcher_token v5),
            (match v6 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_statement ((kind, body) : mt) : CST.if_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v -> trans_elif_clause (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_else_clause (Run.matcher_token v))
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_match_statement ((kind, body) : mt) : CST.match_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4),
            Run.repeat
              (fun v -> trans_case_clause (Run.matcher_token v))
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Simple_stmts (
            trans_simple_statements (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Choice_if_stmt (
            (match v with
            | Alt (0, v) ->
                `If_stmt (
                  trans_if_statement (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `For_stmt (
                  trans_for_statement (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `While_stmt (
                  trans_while_statement (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Try_stmt (
                  trans_try_statement (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `With_stmt (
                  trans_with_statement (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Func_defi (
                  trans_function_definition (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Class_defi (
                  trans_class_definition (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Deco_defi (
                  trans_decorated_definition (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `Match_stmt (
                  trans_match_statement (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_try_statement ((kind, body) : mt) : CST.try_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v3 with
            | Alt (0, v) ->
                `Rep1_except_clause_opt_else_clause_opt_fina_clause (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.repeat1
                          (fun v -> trans_except_clause (Run.matcher_token v))
                          v0
                        ,
                        Run.opt
                          (fun v -> trans_else_clause (Run.matcher_token v))
                          v1
                        ,
                        Run.opt
                          (fun v -> trans_finally_clause (Run.matcher_token v))
                          v2
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Fina_clause (
                  trans_finally_clause (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_statement ((kind, body) : mt) : CST.while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_else_clause (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_with_statement ((kind, body) : mt) : CST.with_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_with_clause (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            (match v4 with
            | Alt (0, v) ->
                `Simple_stmts (
                  trans_simple_statements (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Indent_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_indent (Run.matcher_token v0),
                        trans_block (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Nl (
                  trans_newline (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_module_ ((kind, body) : mt) : CST.module_ =
  match body with
  | Children v ->
      Run.repeat
        (fun v -> trans_statement (Run.matcher_token v))
        v
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_module_ matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

